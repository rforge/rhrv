# Exercise 1.12 Monte_Carlo-Coverage#
# Datum 20.05.2014#
# Lina Puck, Jan Feifel, Lea Müller#
#
monte <- function(sim=100){#
y <- (1:sim)/sim#
nrsamples <- 19#
#
# Erzeugt sim x 19 - Matrix mit gleichverteilten Zufallsvariablen#
samples <- matrix(data = runif(sim* nrsamples), nrow = sim, ncol = nrsamples)#
#
#sortiert Einträge der Matrix spaltenweise#
samples <- apply(samples, 2, sort)#
#
#range angewendet auf die Zeilen gibt jeweils das Maximum und das Minimum aus und speichert das Minumum in 1. Zeile und das Maximum in in 2. Zeile #
#Anschließend wird die entstandene Matrix transponiert#
envelope <- t(apply(samples, 1, range))#
#zeichnet die untere Grenze des Monte-Carlo-Bands#
plot(envelope[, 1], y, col = "red", type="l", xlab=paste(sim,"Sampels"), ylab="Propability" )#
#
#zeichnet die obere Grenze des Monte-Carlo-Bands#
lines(envelope[, 2], y, col = "red")#
#
#sortiert die Zufallsvariablen für die Ausgabe#
s <- sort(runif(sim))#
#
#plottet die Zufallsvariablen#
points(s, y, col=rgb(red=0, blue=0, green=0, alpha=0.2))#
#Berechnung der Überdeckungswahrscheinlichkeit#
hilfsvek <- rep(0,length(s))#
for(i in 1:length(s))#
  {#
  	difmax <- s[i]<envelope[i,2]#
  	difmin <- s[i]>envelope[i,1]#
    # Liegt der Wert s[i] im Monte-Carlo-Band, setze i-te Stelle im Hilfsvektor auf 1#
  	if(difmax && difmin){hilfsvek[i]<- 1} #
  }#
summe<-sum(hilfsvek)#
uewkeit<- (summe/(length(s)))*100#
#
return(uewkeit)#
}
monte()
?plotmath
require(graphics)#
#
x <- seq(-4, 4, len = 101)#
y <- cbind(sin(x), cos(x))#
matplot(x, y, type = "l", xaxt = "n",#
        main = expression(paste(plain(sin) * phi, "  and  ",#
                                plain(cos) * phi)),#
        ylab = expression("sin" * phi, "cos" * phi), # only 1st is taken#
        xlab = expression(paste("Phase Angle ", phi)),#
        col.main = "blue")#
axis(1, at = c(-pi, -pi/2, 0, pi/2, pi),#
     labels = expression(-pi, -pi/2, 0, pi/2, pi))
plot.new(); plot.window(c(0,4), c(15,1))#
text(1, 1, "universal", adj = 0); text(2.5, 1,  "\\042")#
text(3, 1, expression(symbol("\042")))#
text(1, 2, "existential", adj = 0); text(2.5, 2,  "\\044")#
text(3, 2, expression(symbol("\044")))#
text(1, 3, "suchthat", adj = 0); text(2.5, 3,  "\\047")#
text(3, 3, expression(symbol("\047")))#
text(1, 4, "therefore", adj = 0); text(2.5, 4,  "\\134")#
text(3, 4, expression(symbol("\134")))#
text(1, 5, "perpendicular", adj = 0); text(2.5, 5,  "\\136")#
text(3, 5, expression(symbol("\136")))#
text(1, 6, "circlemultiply", adj = 0); text(2.5, 6,  "\\304")#
text(3, 6, expression(symbol("\304")))#
text(1, 7, "circleplus", adj = 0); text(2.5, 7,  "\\305")#
text(3, 7, expression(symbol("\305")))#
text(1, 8, "emptyset", adj = 0); text(2.5, 8,  "\\306")#
text(3, 8, expression(symbol("\306")))#
text(1, 9, "angle", adj = 0); text(2.5, 9,  "\\320")#
text(3, 9, expression(symbol("\320")))#
text(1, 10, "leftangle", adj = 0); text(2.5, 10,  "\\341")#
text(3, 10, expression(symbol("\341")))#
text(1, 11, "rightangle", adj = 0); text(2.5, 11,  "\\361")#
text(3, 11, expression(symbol("\361")))
text(3,3,expressio(F[i]))
text(3,3,expression(F[i]))
ls()
rm(ls())
ls>()
ls()
pi
pi <- 4
pi
ls()
search()
base::pi
pi
2*pi *5
rm(pi)
ls()
rm(pi)
pi
install.packages("sintro",repos="http://r-forge.r-project.org",type="source")
ls()
search()
library(sintro)
ls()
search()
ls("package:sintro")
?text_id
demo(graphics)
?install.packages
ls("package:sintro")
?OddOneOut
OddOneOut(runs=5, ncols=3)
?load
load('~/Desktop/CompStat_Rintro/20140512.Rdata')#
#
plot(pwrunifhist, col="red", ylim=c(0,1), log="x", #
	ylab=expression(p[rejection]),#
	main="Visual inspection\n histogram and distribution function\n uniform random samples")#
points(pwrunifecdf, col="blue")#
abline(h=0.1, col="green")#
legend("topright",#
	legend=c("histogram", "distribution function"),#
	bty="n", #
	pch=1,#
	col=c("red", "blue")#
	)#
arrows(15,0.2, 10, 0.1, col="green")#
text(15,0.2, #
	labels=expression(p[rejection]==0.1), #
	pos=3,#
	cex=0.8, col="green")#
title(sub="logarithmic scale")
plot(lm(p_rej ~ log(n), data=pwrunifhist))
load('~/Desktop/CompStat_Rintro/20140512.Rdata')
ls()
plot(pwrunifhist, col="red", ylim=c(0,1), log="x", #
	ylab=expression(p[rejection]),#
	main="Visual inspection\n histogram and distribution function\n uniform random samples")
points(pwrunifecdf, col="blue")
abline(h=0.1, col="green")
legend("topright",#
	legend=c("histogram", "distribution function"),#
	bty="n", #
	pch=1,#
	col=c("red", "blue")#
	)
arrows(15,0.2, 10, 0.1, col="green")
text(15,0.2, #
	labels=expression(p[rejection]==0.1), #
	pos=3,#
	cex=0.8, col="green")
title(sub="logarithmic scale")
n <-100#
a <- 2.3#
b <- 1.8#
x <- runif(n)#
y <- a + b*x + rnorm(n)
plot(x,y)
lm( y ~ x)
abline(lm( y ~ x))
y2  <- a + b*x*x + rnorm(n)
lm( y2 ~ x)
plot(x,y)
plot(x,y2)
abline(lm( y2 ~ x))
lmres <- lm( y2 ~ x)
lmres
summary(lmres)
str(lmres)
plot(lm(p_rej ~ log(n), data=pwrunifhist))
lm(p_rej ~ log(n), data=pwrunifhist)
summary(lm(p_rej ~ log(n), data=pwrunifhist))
plot(lm(p_rej ~ log(n), data=pwrunifhist))
ls()
exercise1 <- function(){#
  l <- 100#
  y <- (1:l)/l #plot(sort(x), y)#
  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
  plot(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot) und die erste generierte Verteilungsfunktion (blau)")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1()
exercise1 <- function(){#
  l <- 100#
  y <- (1:l)/l #plot(sort(x), y)#
  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
  	#gs#
  	points(testsamples[, i],y, col=rgb(0,1,0,0.2))#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
  plot(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot) und die erste generierte Verteilungsfunktion (blau)")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1()
exercise1 <- function(x, nsamples=19){#
  l <- length(x) #gs#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und die erste generierte Verteilungsfunktion (blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col=rgb(0,1,0,0.1),   	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   poits(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
exercise1 <- function(x, nsamples=19){#
  l <- length(x) #gs#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und die erste generierte Verteilungsfunktion (blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col=rgb(0,1,0,0.1)) 	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   poits(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
exercise1(sin(1:100))
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nsamples=19){#
  l <- length(x) #gs#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und die erste generierte Verteilungsfunktion (blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col=rgb(0,1,0,0.1)) 	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   poits(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nsamples=19, sim=1000){#
  l <- length(x) #gs#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(x, y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und Verteilungsfunktion der Sample-Daten(blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
#gs als Parameter übergeben #
# sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col=rgb(0,1,0,0.1)) 	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   poits(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nrsamples=19, sim=1000){#
  l <- length(x) #gs#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(x, y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und Verteilungsfunktion der Sample-Daten(blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
#gs als Parameter übergeben #
# sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col=rgb(0,1,0,0.1)) 	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   poits(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nrsamples=19, sim=1000){#
  l <- length(x) #gs#
  x <- sort(x)#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(x, y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und Verteilungsfunktion der Sample-Daten(blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
#gs als Parameter übergeben #
# sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col=rgb(0,1,0,0.1)) 	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   points(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nrsamples=19, sim=1000){#
  l <- length(x) #gs#
  # shift to []0,1]#
  x <- x - min(x)#
  x <- x/max(1)#
  x <- sort(x)#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(x, y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und Verteilungsfunktion der Sample-Daten(blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
#gs als Parameter übergeben #
# sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,1], y, xlab="x", ylab=expression(F[n]), pch=20, col=rgb(0,1,0,0.1)) 	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   points(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nrsamples=19, sim=1000){#
  l <- length(x) #gs#
  # shift to []0,1]#
  x <- x - min(x)#
  x <- x/max(x)#
  x <- sort(x)#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(x, y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und Verteilungsfunktion der Sample-Daten(blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
#gs als Parameter übergeben #
# sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,i], y, pch=20, col=rgb(0,1,0,0.1)) 	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   points(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
?rgb
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nrsamples=19, sim=1000){#
  l <- length(x) #gs#
  # shift to []0,1]#
  x <- x - min(x)#
  x <- x/max(x)#
  x <- sort(x)#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(x, y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und Verteilungsfunktion der Sample-Daten(blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
#gs als Parameter übergeben #
# sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,i], y, pch=20, col=rgb(0,1,0,0.9)) 	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   points(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nrsamples=19, sim=1000){#
  l <- length(x) #gs#
  # shift to []0,1]#
  x <- x - min(x)#
  x <- x/max(x)#
  x <- sort(x)#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(x, y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und Verteilungsfunktion der Sample-Daten(blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
#gs als Parameter übergeben #
# sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,i], y, pch=20, col=rgb(0,1,0,0.05)) 	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   points(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nrsamples=19, sim=1000){#
  l <- length(x) #gs#
  # shift to []0,1]#
  x <- x - min(x)#
  x <- x/max(x)#
  x <- sort(x)#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(x, y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und Verteilungsfunktion der Sample-Daten(blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
#gs als Parameter übergeben #
# sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,i], y, pch=20, col=rgb(0,1,0,min(0.1,10/sim)) # alpha-Wert:	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   points(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
# Maren Hilgert\n#
# 15-05-2014\n#
# Aufgabe 1.12 Monte Carlo Coverage\n#
#
# Die Coverage Wahrscheinlichkeit liegt im Durchschnitt bei etwa 20-25%, die Varianz hierbei ist ziemlich hoch. \n#
# Der Test wurde so konzipiert, dass er  verworfen wird, sobald einer der Punkte außerhalb des Bandes liegt. Die Hypothese einer Gleichverteilung wird somit häufig verworfen.\n#
# modifiziert:  gs#
exercise1 <- function(x, nrsamples=19, sim=1000){#
  l <- length(x) #gs#
  # shift to []0,1]#
  x <- x - min(x)#
  x <- x/max(x)#
  x <- sort(x)#
y <- (1:l)/l #plot(sort(x), y)#
#
 plot(x, y, xlab="x", ylab=expression(F[n]), pch=20, col="blue", main="Monte-Carlo-Bänder (rot)\n und Verteilungsfunktion der Sample-Daten(blau)")  #
#gs nrsamples  als Parameter gesetzt#
#  nrsamples <- 19 # Anzahl der Simulationen für Monte-Carlo-Bänder (siehe Aufgabentext)#
  samples <- matrix(data = runif(l * nrsamples),#
                    nrow = l, ncol = nrsamples)#
  samples <- apply(samples, 2, sort) #Sortiert nach der Größe#
  envelope <- t(apply(samples, 1, range))  #Wählt den Größten und den Kleinsten Wert aus#
#gs als Parameter übergeben #
# sim=1000 #Anzahl der Simulationen (Variabel)#
  testsamples <- matrix(data=runif(sim*100),#
                        nrow = 100, ncol = sim)#
  testsamples <- apply(testsamples, 2, sort) #Sortiert die Daten der Matrix zum Vergleich mit den Monte-Carlo-Bändern#
  inside <- 0#
  for (i in 1:sim) { #Vergleicht jede Simulation mit den Monte-Carlo-Bändern#
   points(testsamples[,i], y, pch=20, col=rgb(0,1,0,min(0.1, 5/sim)) # alpha-Wert:	#
   if ( (all(testsamples[, i] >= envelope[, 1])) && (all(testsamples[, i] <= envelope[, 2])) )#
      inside <- inside +1#
  } #für den Fall, dass ein Wert der Funktion überhalb oder unterhalb der Max/Min-Werte der MonteCarloBänder liegt, wird dies gezählt#
print(inside / (sim))# Die Übergangswahrscheinlichkeit entspricht nun der Anzahl der Simulationen, die innerhalb der Monte-Carlo-Bänder lagen, geteilt durch die gesamte Anzahl der Simulationen#
  #plot(envelope[, 1], y, type="n")#
   points(x, y, xlab="x", pch=20, col="blue")#
#Stellt den Plot er ersten generierten Verteilung dar#
  lines(envelope[, 1], y, col = "red") #Stellt ein Monte-Carlo-Band#
  lines(envelope[, 2], y, col = "red") #stellt das zweite Monte-Carlo-Band dar#
abline(0,1)#
}#
exercise1(sin(1:100))
?par
library(MASS)#
help(hills)
pairs(hills[, 1:3])
hills[18,]$time <- 18.65#
rownames(hills)[18] <- "Knock H.fxd"#
#
pairs(hills[, 1:3])
hills_lm <- lm(time ~ dist + climb, #
	data = hills)#
#
summar(hills_lm)
summary(hills_lm)
par(mfrow = c(2, 2))#
plot(hills_lm, which = c(1, 2, 5))#
#
frame()
hills_lm0 <- lm(time ~ 0+ dist + climb, #
	data = hills)
summary(hills_lm0)
?influence.measures
ls
plot(hills_lm, which = c(1, 2, 5))
par(mfrow = c(2, 2))#
plot(hills_lm, which = c(1, 2, 5))#
#
frame()
plot
methods(plot, class=class(hills_lm))
plot.ecdf
plot.lm
library(car)
?leveragePlot
library(car)
avPlots(lm(prestige~income+education+type, data=Duncan))
m1 <- lm(prestige ~ income, data=Prestige)#
residualPlots(m1)
avPlots(hills_lm)
hills_lm <- lm(time ~ dist + climb, #
	data = hills)
library(MASS)
hills_lm <- lm(time ~ dist + climb, #
	data = hills)#
avPlots(hills_lm)
library(MASS)
hills[18,]$time <- 18.65#
rownames(hills)[18] <- "Knock H.fxd"
hills_lm <- lm(time ~ dist + climb, #
	data = hills)
plot(hills_lm)
attach(hills)
plot(dist,time)
names(hills_lm)
?influenceMeasures
influence.lm
?lm.influence
pairs(hills)
summary(hills_lm)
hills_lm0 <- lm(time ~ 0+  dist + climb, #
	data = hills)#
summary(hills_lm0)
hills_lm00 <- lm(time ~ 0+  dist , #
	data = hills)#
summary(hills_lm00)
library(car)#
avPlots(hills_lm)
avPlots
?mtext
?leveragePlot
power_test <- function (a, b, testtype, n=50, m=500, alpha=.05 )#
{#
  #switch for the type of test to apply#
  testfunc <- function (x, testtype)#
  {#
    switch(testtype,#
           ks = {#
             ks.test(x, punif)#
           },#
           chisq= {#
             histcounts <- hist(x, breaks=10)$counts#
             chisq.test(histcounts)#
           }#
    )#
  }#
  n_rejected <- 0#
  for (i in (1:m))#
  {#
    #sampling#
    current_samples <- rbeta(n, a, b)#
    statistic_value <- testfunc(current_samples, testtype)#
    #checking whether the 'uniform-hypothesis' should be rejected#
    if (statistic_value$p.value <= alpha ) {n_rejected <- n_rejected+1} #
#
  }#
  #fraction of rejected samples#
  return(n_rejected/m)   #
}
power_test_vectorized <- Vectorize(power_test)#
#
#Parameter range for beta distr. param.s 'a', 'b'.#
param_range <- (1:5)
ks_matrix <- outer(param_range, param_range, power_test_vectorized, testtype="ks")#
chisq_matrix <-outer(param_range, param_range, power_test_vectorized, testtype="chisq")
print("Kolmogorov-Smirnov-Test, Fraction of Rejected Samples")#
print(ks_matrix)#
print("Chi-Squared-Test, Fraction of Rejected Samples")#
print(chisq_matrix)
#graphical output#
par(mfrow=c(2,1))#
contour(param_range, param_range, ks_matrix)#
title(main="Kolmogorov-Smirnov-Test\n Fraction of Rejected Samples", #
      xlab="Parameter a", ylab="Parameter b")#
#
contour(param_range, param_range, chisq_matrix)#
title(main="Chi-Squared-Test\n Fraction of Rejected Samples", #
      xlab="Parameter a", ylab="Parameter b")
library(MASS)#
#
#hills["Knock Hill",]$time <- 78.65#
hills[18,]$time <- 18.65#
rownames(hills)[18] <- "Knock H.fxd"#
#
hills_lm <- lm(time ~ dist + climb, #
	data = hills)
summary(hills_lm)
library(car)#
avPlots(hills_lm)
avPlots
?hist
?chisq.test
min
max
range
?lm
lm
plot.lm
methods(plot)
plot.default
range
oneway <- function(data_table){#
y<-as.vector(data_table)#
width<-dim(mymatrix)[2]#
height<-dim(mymatrix)[1]#
k=1#
for (j in 1:width){for (i in 1:height) {x[k]=j;k=k+1;}}#
y~factor(x)#
lm(y~factor(x))#
mod <- lm(y~factor(x))#
par(mfrow=c(2,2))#
plot(mod, col="blue")#
par(oma = c(0, 0, 2, 0))#
mtext("Aufgabe 2.13 One-Way Analysis of Variance", outer = TRUE, cex = 1.5)#
return(summary(lm(y~factor(x))))#
}
#Matrix1#
a <- c(12,13,15,9,10,11,9,11)                      #
b <- c(3,5,2,3,5,7,5,6)      #
d <- c(20,19,15,19,17,21,19,21)                      #
e <- c(2,5,4,3,5,2,5,6)                       #
mymatrix <- matrix(c(a,b,d,e),8)#
oneway(mymatrix)
library(rggobi)
install.packages("rggobi", type = "source")
ls()
library(MASS); lda()
?lda
?coplot
ll.dm <- lat ~ long | depth * mag#
coplot(ll.dm, data = quakes)#
coplot(ll.dm, data = quakes, number = c(4, 7), show.given = c(TRUE, FALSE))#
coplot(ll.dm, data = quakes, number = c(3, 7),#
       overlap = c(-.5, .1)) # negative overlap DROPS values
library(UsingR)
?fat
?scaale
?scale
scale
methods(scale)
scale.default
oldoptions<-options(width=72,prompt="  ", continue="  "); setwd("/Users/gs/projects/rforge/rhrv/gs/Rnw_out"); Sweave(file= "../Rnw/recurrence.Rnw", output="recurrence.tex", debug=TRUE, eps=FALSE, figs.only=FALSE); options(oldoptions)
oldoptions<-options(width=72,prompt="  ", continue="  "); setwd("/Users/gs/projects/rforge/rhrv/gs/Rnw_out"); Sweave(file= "../Rnw/recurrence.Rnw", output="recurrence.tex", debug=TRUE, eps=FALSE, figs.only=FALSE); options(oldoptions)
oldoptions<-options(width=72,prompt="  ", continue="  "); setwd("/Users/gs/projects/rforge/rhrv/gs/Rnw_out"); Sweave(file= "../Rnw/recurrence.Rnw", output="recurrence.tex", debug=TRUE, eps=FALSE, figs.only=FALSE); options(oldoptions)
